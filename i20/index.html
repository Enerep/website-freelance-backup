


<!DOCTYPE html>
<html lang="en">




<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS portfolio</title>
    <style>




        :root {
            --bg: #020205;
            --text: #e0e0e0;
            --cyan: #00f7ff;
            --purple: #5e42a6;
            --font-mono: 'Courier Prime', 'Roboto Mono', monospace;
        }





        * {
            margin: 0; padding: 0; box-sizing: border-box;
            cursor: none !important; /* Hide system cursor */
        }




        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-mono);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            position: fixed; top: 0; left: 0;
            z-index: 1;
        }

        /* costum cursor */
        .cursor-target {
            position: fixed; top: 0; left: 0;
            width: 40px; height: 40px;
            margin: -20px 0 0 -20px;
            border: 2px solid var(--cyan);
            border-radius: 50%;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 0 15px var(--cyan), inset 0 0 5px var(--cyan);
            transition: width 0.2s, height 0.2s;
        }

        .cursor-center {
            position: fixed; top: 0; left: 0;
            width: 6px; height: 6px;
            margin: -3px 0 0 -3px;
            background: var(--cyan);
            border-radius: 50%;
            z-index: 1001;
            pointer-events: none;
        }




        /*UI overlay */
        main {
            position: relative;
            z-index: 10;
            text-align: left;
            pointer-events: none; /*let clicks pass through to canvas if needed */
            user-select: none;
        }




        h1.glitch-header {
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 700;
            letter-spacing: -0.02em;
            color: var(--cyan);
            text-transform: uppercase;
            position: relative;
            text-shadow: 2px 0px 5px rgba(0, 247, 255, 0.5);
        }




        
        h1.glitch-header::after {
            content: 'NEXUS_CORE';
            position: absolute;
            left: 2px; top: 2px;
            color: var(--purple);
            opacity: 0.5;
            z-index: -1;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
            animation: glitchAnim 2s infinite linear alternate-reverse;
        }





        @keyframes glitchAnim {
            0% { clip-path: polygon(0 30%, 100% 30%, 100% 50%, 0 50%); transform: translate(-2px); }
            20% { clip-path: polygon(0 10%, 100% 10%, 100% 30%, 0 30%); transform: translate(2px); }
            100% { clip-path: polygon(0 50%, 100% 50%, 100% 80%, 0 80%); transform: translate(0); }
        }

        .status-bar {
            position: fixed;
            bottom: 30px; left: 30px;
            font-size: 0.8rem;
            color: var(--cyan);
            opacity: 0.7;
            display: flex;
            gap: 20px;
        }
        .status-blink { animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

    </style>
</head>



<body>

    <canvas id="canvas"></canvas>
    <div class="cursor-target" id="c-target"></div>
    <div class="cursor-center" id="c-center"></div>




    <main>
        <div>
            <p style="letter-spacing: 0.2em; margin-bottom: 10px;">// SYSTEM ARCHITECT</p>
            <h1 class="glitch-header">NEXUS_CORE</h1>
            <p style="max-width: 400px; margin-top: 20px; line-height: 1.5; opacity: 0.8;">
                Developing high-performance digital.
            </p>
        </div>


    </main>



    <div class="status-bar">
        <span>STATUS: <span class="status-blink">ONLINE</span></span>
        <span id="coords">COORDS: 0000.0000</span>
    </div>






    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        //LERP for smooth cursor functionality
        const lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let cursorX = mouse.x, cursorY = mouse.y;

        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            //update coordinate UI
            document.getElementById('coords').innerText = `COORDS: ${mouse.x.toFixed(0).padStart(4, '0')}.${mouse.y.toFixed(0).padStart(4, '0')}`;
        });



        //network simul
        const particleCount = 120;
        const connectionDistance = 150; 
        const mouseInfluenceRadius = 250;
        let particles = [];






        class Particle {
            constructor() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                //base velocity (drifting)
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 1.5 + 1;
            }

            update() {
                // 1. standard drifting
                this.x += this.vx;
                this.y += this.vy;


                // 2.bounce off screen edges
                if (this.x < 0 || this.x > width) this.vx *= -1;
                if (this.y < 0 || this.y > height) this.vy *= -1;


                // 3. THE INSANE PART:mouse gravity well
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let dist = Math.sqrt(dx * dx + dy * dy);




                if (dist < mouseInfluenceRadius) {
                    //pull towards mouse. the closer it is, the stronger the pull.
                    const force = (mouseInfluenceRadius - dist) / mouseInfluenceRadius;
                    this.x += dx * force * 0.03; 
                    this.y += dy * force * 0.03;
                }
            }




            draw() {
                // draw the node itself
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                // nodes near mouse are cyan, far away are purple
                let distToMouse = Math.hypot(this.x - mouse.x, this.y - mouse.y);
                if (distToMouse < mouseInfluenceRadius) {
                    ctx.fillStyle = '#00f7ff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00f7ff';
                } else {
                    ctx.fillStyle = '#5e42a6';
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        }




        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // 1. update and draw particles
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // 2.draw cconnections 
            //we use a nested loop to check every particle against every other particle
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let p1 = particles[i];
                    let p2 = particles[j];
                    let dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);

                    if (dist < connectionDistance) {
                        //clculate opacity based on distance (closer = clearer)
                        let opacity = 1 - (dist / connectionDistance);
                        
                        //check if this connection is near the mouse
                        let midX = (p1.x + p2.x)/2;
                        let midY = (p1.y + p2.y)/2;
                        let distToMouse = Math.hypot(midX - mouse.x, midY - mouse.y);

                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);

                        if (distToMouse < mouseInfluenceRadius) {
                            ctx.strokeStyle = `rgba(0, 247, 255, ${opacity})`;
                            ctx.lineWidth = 2 * opacity;
                            ctx.shadowBlur = 5;
                            ctx.shadowColor = '#00f7ff';
                        } else {
                            // DORMANT CONNECTION (Far away)
                            ctx.strokeStyle = `rgba(94, 66, 166, ${opacity * 0.5})`;
                            ctx.lineWidth = 0.5;
                            ctx.shadowBlur = 0;
                        }
                        ctx.stroke();
                    }
                }
            }

            ctx.shadowBlur = 0;

            // 3.update custom cursor with LERP smoothness
            cursorX = lerp(cursorX, mouse.x, 0.15);
            cursorY = lerp(cursorY, mouse.y, 0.15);
            document.getElementById('c-target').style.transform = `translate(${cursorX}px, ${cursorY}px)`;
            document.getElementById('c-center').style.transform = `translate(${mouse.x}px, ${mouse.y}px)`;

            requestAnimationFrame(animate);
        }

        
        document.addEventListener('mousedown', () => {
            document.getElementById('c-target').style.transform += ' scale(0.8)';
        });
        document.addEventListener('mouseup', () => {
             document.getElementById('c-target').style.transform = document.getElementById('c-target').style.transform.replace(' scale(0.8)', '');
        });

        window.addEventListener('resize', init);
        init();
        animate();


    </script>







</body>
</html>